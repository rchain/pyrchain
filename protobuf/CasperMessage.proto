/**
 * The main API is `DeployService`.
 */
syntax = "proto3";

package casper;

// If you are building for other languages "scalapb.proto"
// can be manually obtained here:
// https://raw.githubusercontent.com/scalapb/ScalaPB/master/protobuf/scalapb/scalapb.proto
// make a scalapb directory in this file's location and place it inside

import "scalapb/scalapb.proto";
import "RhoTypes.proto";

option (scalapb.options) = {
  package_name: "coop.rchain.casper.protocol"
  flat_package: true
  single_file: true
  preamble: "sealed trait CasperMessageProto"
  preserve_unknown_fields: false
};

// ---------- Approved block ---------

message ApprovedBlockProto  {
  option (scalapb.message).extends = "CasperMessageProto";
  BlockMessageProto block  = 1 [(scalapb.field).no_box = true];
}

message ApprovedBlockRequestProto {
  option (scalapb.message).extends = "CasperMessageProto";
  string identifier = 1;
  bool   trimState  = 2;
}

message NoApprovedBlockAvailableProto {
  option (scalapb.message).extends = "CasperMessageProto";
  string identifier    = 1;
  string nodeIdentifer = 2;
}

// ------- End Approved block --------

message ForkChoiceTipRequestProto {
  option (scalapb.message).extends = "CasperMessageProto";
}

message HasBlockRequestProto {
  option (scalapb.message).extends = "CasperMessageProto";
  bytes  hash = 1;
}

message HasBlockProto {
  option (scalapb.message).extends = "CasperMessageProto";
  bytes  hash = 1;
}

message BlockRequestProto {
  option (scalapb.message).extends = "CasperMessageProto";
  bytes  hash = 1;
}

message BlockHashMessageProto {
  option (scalapb.message).extends = "CasperMessageProto";
  bytes  hash         = 1;
  bytes  blockCreator = 2;
}

// --------- Core Protocol  --------

message BlockMessageProto {
  option (scalapb.message).extends = "CasperMessageProto";
  int32              version        =  1; // version number to define how block is serialized and hashed
  string             shardId        =  2; // identifier of the shard where the block was created
  bytes              blockHash      =  3; // obtained by hashing all information in the block except signature
  int64              blockNumber    =  4;
  bytes              sender         =  5; // public key of the validator that created the block
  int64              seqNum         =  6; // number of blocks created by the validator
  bytes              preStateHash   =  7; // hash of the tuplespace contents before new deploys
  bytes              postStateHash  =  8; // hash of the tuplespace contents after new deploys
  repeated bytes     justifications =  9 [(scalapb.field).collection_type="List"]; // map of all validators to latest blocks based on current view
  repeated BondProto bonds          = 10 [(scalapb.field).collection_type="List"]; // validators and their stakes
  // Rejected data in finalized fringe
  repeated bytes rejectedDeploys    = 11 [(scalapb.field).collection_type="List"];
  repeated bytes rejectedBlocks     = 12 [(scalapb.field).collection_type="List"];
  repeated bytes rejectedSenders    = 13 [(scalapb.field).collection_type="List"];
  // Rholang execution trace
  RholangStateProto  state          = 14 [(scalapb.field).no_box = true];
  // Block signature
  string             sigAlgorithm   = 15; // name of the algorithm used to sign
  bytes              sig            = 16; // signature generated by signing blockHash
}

message DeployDataProto {
  bytes  deployer              =  1; // public key
  string term                  =  2; // Rholang source code to deploy (will be parsed into `Par`)
  int64  timestamp             =  3; // number for user to create different signature for the same deploy data
  bytes  sig                   =  4; // signature of (hash(term) + timestamp) using private key
  string sigAlgorithm          =  5; // name of the algorithm used to sign
  int64  phloPrice             =  7; // phlo price
  int64  phloLimit             =  8; // phlo limit for the deployment
  int64  validAfterBlockNumber = 10;
  string shardId               = 11; // shard ID to prevent replay of deploys between shards
}

message RholangStateProto {
  repeated ProcessedDeployProto       deploys         = 1;
  repeated ProcessedSystemDeployProto systemDeploys   = 2;
}

message ProcessedDeployProto {
  DeployDataProto deploy        = 1 [(scalapb.field).no_box = true]; // user deploy
  PCost cost                    = 2 [(scalapb.field).no_box = true]; // cost for execution of user deploy
  repeated EventProto deployLog = 3; // Rholang execution trace for deploy
  bool errored                  = 4; // true if deploy encountered a user error
  string systemDeployError      = 5; // error message for system deploy
}

message SlashSystemDeployDataProto {
  bytes slashedValidator = 1;
}

message CloseBlockSystemDeployDataProto{
}

message SystemDeployDataProto{
  oneof systemDeploy{
    SlashSystemDeployDataProto slashSystemDeploy = 1;
    CloseBlockSystemDeployDataProto closeBlockSystemDeploy = 2;
  }
}

message ProcessedSystemDeployProto {
  SystemDeployDataProto systemDeploy = 1 [(scalapb.field).no_box = true];
  repeated EventProto deployLog      = 2;
  string errorMsg                    = 3;
}

message RejectedDeployProto{
  bytes sig = 1;
}

message EventProto {
  oneof event_instance {
    ProduceEventProto produce = 1;
    ConsumeEventProto consume = 2;
    CommEventProto comm       = 3;
  }
}

message ProduceEventProto {
  bytes channelsHash  = 1;
  bytes hash          = 2;
  bool persistent     = 3;
  int32 timesRepeated = 4;
}

message ConsumeEventProto {
  repeated bytes channelsHashes = 1;
  bytes hash                    = 2;
  bool persistent               = 3;
}

message CommEventProto {
  ConsumeEventProto consume           = 1 [(scalapb.field).no_box = true];
  repeated ProduceEventProto produces = 2;
  repeated PeekProto peeks            = 3;
}

message PeekProto {
  int32 channelIndex = 1;
}

message BondProto {
  bytes validator = 1;
  int64 stake     = 2;
}

// --------- End Core Protocol  --------

// --------- Last finalized state  --------

message StoreNodeKeyProto {
  bytes hash  = 1;
  int32 index = 2;
}

message StoreItemsMessageRequestProto {
  option (scalapb.message).extends = "CasperMessageProto";
  repeated StoreNodeKeyProto startPath = 1 [(scalapb.field).collection_type="List"];
  int32 skip                           = 2;
  int32 take                           = 3;
}

message StoreItemProto {
  bytes key   = 1;
  bytes value = 2;
}

message StoreItemsMessageProto {
  option (scalapb.message).extends = "CasperMessageProto";
  repeated StoreNodeKeyProto startPath = 1 [(scalapb.field).collection_type="List"];
  repeated StoreNodeKeyProto lastPath  = 2 [(scalapb.field).collection_type="List"];
  repeated StoreItemProto historyItems = 3 [(scalapb.field).collection_type="List"];
  repeated StoreItemProto dataItems    = 4 [(scalapb.field).collection_type="List"];
}

// --------- End Last finalized state  --------

// --------- Internal types ---------

message BlockMetadataProto {
  bytes blockHash               = 1;
  int64 blockNum                = 2;
  bytes sender                  = 3;
  int64 seqNum                  = 4;
  repeated bytes justifications = 5 [(scalapb.field).collection_type="List"];
  repeated BondProto bonds      = 6 [(scalapb.field).collection_type="List"];
  bool invalid                  = 7; // whether the block was marked as invalid

  bool directlyFinalized        = 20; // whether the block has been last finalized block (LFB)
  bool finalized                = 21; // whether the block is finalized
  repeated bytes parents        = 22 [(scalapb.field).collection_type="List"];
}

// --------- End Internal types ---------
